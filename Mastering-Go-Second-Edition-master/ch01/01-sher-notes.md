## page 20
printing to standard output can be done using

```
fmt.Println()  // this adds newline at the end 
fmt.Print()    // this doesn't add newline
```


There's also:

fmt.Printf()

This is like fmt.Print() but let's you do formatting, which in turn means write more code:

```
package main

import "fmt"

func main() {

	name := "Peter Parker"
	city := "New York"
	age := 18

        fmt.Print(name, city, age) // no spaces here
        fmt.Println(name, city, age)  // no spaces here, but new line
	fmt.Printf("my name is %s, I live in %s, and i am %d years old\n", name, city, age)

}
```

All three above are used to output to screen. 


https://play.golang.org/p/1bK76lMVPhM





## page 22

there's also Sprintf, Sprint, and Sprintln

These are used to construct string variable and store them in a another variable, e.g. 

```
package main

import "fmt"

func main() {

	name := "Peter Parker"
	city := "New York"
	age := 18

	sentence := fmt.Sprintf("my name is %s, I live in %s, and i am %d years old\n", name, city, age)

        fmt.Print(sentence)
}
```

https://play.golang.org/p/m_hsSuQCbKw


Similarly we have Fprintf, Fprint, and Fprintln:

```go
package main

import (
    "fmt"
    "os"
)


func main() {

	name := "Peter Parker"
	city := "New York"
	age := 18

	fmt.Fprintln(os.Stdout, "my name is", name, "I live in", city, "I am", age, "years old")
	fmt.Fprintln(os.Stdout, "")
	fmt.Fprint(os.Stdout, "my name is", name, "I live in", city, "I am", age, "years old")
        fmt.Fprintln(os.Stdout, "")
	fmt.Fprintf(os.Stdout, "my name is %s", name)
}
```
https://play.golang.org/p/0TPfoxpZ-_S



## page 23

https://github.com/Sher-Chowdhury/gsg_binary_that_uses_cli_parameters/blob/master/main.go


## page 25

https://github.com/Sher-Chowdhury/gsg_interactive_binary/blob/master/main.go


## page 31

Your go project should be able to write logs to the standard log files located under the `/var/log` folder like any other app, e.g. `/var/log/messages`. You can do this using the log package:

https://golang.org/pkg/log/

To use this package you need to define to parameters:

- log level  - debug, info, notice, warning, err, crit, alert, and emerg 
- log facility - auth, authpriv, cron, daemon, kern, lpr, mail, mark, news, syslog, user, UUCP, local0, local1, local2, local3, local4, local5, local6, and local7.

on Centos 8, the log facilities are found here

```
man 5 rsyslog.conf
```
https://codingbee.net/centos/man-how-to-fix-the-no-manual-entry-for

Which lists them as:

```
auth, authpriv, cron, daemon, kern,
       lpr, mail, mark, news, security (same as auth),  syslog,  user,  uucp  and  local0
       through  local7.
```

Similarly for priority (log-level) we have the following extract:

```
The priority is one of the following keywords, in ascending order:
       debug, info, notice, warning, warn (same as warning),  err,  error
       (same as err), crit, alert, emerg, panic (same as emerg). The key‚Äê
       words error, warn and panic are deprecated and should not be  used
       anymore. The priority defines the severity of the message.
```



log facility controls which log file to store a log entry in. e.g. if set to 'syslog' then it will get stored in /var/log/messages

https://codingbee.net/rhcsa/rhcsa-rsyslog-logging

```go
package main

import (
	"fmt"
	"log"
	"log/syslog"
	"os"
	"path/filepath"
)

func main() {

        // by defualt this will go to the standard output, it includes a datestamp
	// which makes it suitable for showing progress of binary rather
	// than just using fmt.Println() all the time.
	log.Print("Hello Logs!")
	// we can customise this to send logs elsewhere.

	// Here we're finding out our binary's filename.
	// we need this to label our log entries with it as best practice
	fmt.Println(os.Args)
	programName := filepath.Base(os.Args[0])
	fmt.Println(programName)

	// Here we are choosing what log-level and log-facility we want to use
        // https://golang.org/pkg/log/syslog/#Priority has the available options
	infoLog, _ := syslog.New(syslog.LOG_INFO|syslog.LOG_LOCAL7, programName)

	// here we are activating our log info settings, in preparation to
	// writing to system logs
	log.SetOutput(infoLog)

	// this sends the messate to /var/log/messages along with other places
	// as defined in the rsyslog.conf file.
	log.Println("This info log entry was generated by my golang binary")

}
```
https://yourbasic.org/golang/log-to-file/



## ????

About Log.Fatal

Sometimes you'll want to issue a log message and then straight away exit the program. That can be done using log.Fatal. 


```go
package main

import (
	"fmt"
	"log"
	"log/syslog"
)

func main() {
	sysLog, _ := syslog.New(syslog.LOG_ALERT|syslog.LOG_SYSLOG, "Something really bad has happened!!!")

	log.SetOutput(sysLog)

	// on a CentOS vm, this sends a log entry to /var/log/messages with the message "Something really bad has happened!!!"
	log.Fatal(sysLog)
	fmt.Println("The above line will terminate this program before this line has a chance to get executed")
}
```

a quick way to try this out is by running:

```
$ vagrant init bento/centos-8
$ vagrant up
$ vagrant ssh
$ sudo su -
$ go run /vagrant/logFatal-sher.go
exit status 1
grep -ir "Something really bad has happened" /var/log
/var/log/messages:Nov 15 14:55:22 localhost journal[12270]: Something really bad has happened!!![12270]: 2019/11/15 14:55:22 &{41 Something really bad has happened!!! localhost.localdomain   {0 0} 0xc00000c100}
```

log.Fatal() only gives the output "exit status 1".

However if you want to still terminate straight away but also give slightly more verbose output, then use log.Panic() instead, and all else being the same. The output will then be something like:

```
go run logPanic-sher.go
panic: &{41 Something really bad has happened!!! localhost.localdomain   {0 0} 0xc00000c100}

goroutine 1 [running]:
log.Panic(0xc000045f78, 0x1, 0x1)
	/usr/lib/golang/src/log/log.go:326 +0xc0
main.main()
	/root/logPanic-sher.go:15 +0xa0
exit status 2
```

it will still output message to /var/log/messages too. 




## Page ???? - Error handling



